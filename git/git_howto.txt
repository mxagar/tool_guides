GIT Howto (for SVN Users)
Mikel Sagardia, 2020

## Resources (sources for creating this guide)

	https://git-scm.com/course/svn.html
	https://www.git-tower.com/blog/git-for-subversion-users-cheat-sheet/
	https://blog.udacity.com/2015/06/a-beginners-git-github-tutorial.html
	https://guides.github.com/activities/hello-world/

	Udemy courses
		GitHub Ultimate: Master Git and GitHub
		GitLab CI: Pipelines, CI/CD and DevOps for Beginners

## Index

	Basic: Crash Course
	Teamwork: branches & merges
	Creating a new repository locally
	Admin / Management of repos
	Git tags
	Git configuration
	Github: Intro
	Markdown syntax / README.md
	CFG files
	Udacity Github Good Practices
	Tips & Tricks & Issues
	SSH Authentication
	Access Tokens
	Social Coding: Fork, Change on Branch, Pull Request
	Merging an upstream repository into your fork
	Merge conflicts
	Github Issues
	Github Gists
	Github Organizations
	A successful Git branching model
	Workflow: Working on Teams
	Workflow: Fork-Branch-Pull-Request
	Gitlab CI/CD
	DVC
	Git summary for working in teams

## Basic: Crash Course

	- GIT has a local/private repo, accessible only by user and remote/public accessible by all
	- Interface: GIT command line: (Windows) Context Menu with right click -> GIT Bash here

	git clone <URL.git> = svn checkout <URL>
		check out remote repo for first time to a local location
		to get the URL, click on browser on download/clone button
		important: the URL should end with '.git'
		the URL should be like this also
			ssh://git@example.com/path/git-repo.git

	git add <file/folder> = svn add <file/folder>
		add new files or stage changed ones before committing
		if option -p added, files are added interactively and the user can check differences ... (?)
		staging: IMPORTANT
			gitadd is not only for adding new files!
			it's also for _staging_ (preparar, apilar) files before a commit
			example:
				we have 10 files f_i
				we change files f_1 - f_5
				we want to commit changes to f_1 - f_3 and f_4 - f_5 in two separate blocks
				we stage them in two blocks
					git add f_1 f_2 f_3
					git commit
					git add f_4 f_5
					git commit

	vim .gitignore
		edit file
		add files that should be ignored
		example:
			# ignore all docs
			*.doc
			*.docx
			# ignore concrete files
			myfile.log

	git add -f myfile.log
	git commit -m "force adding myfile.log"

	git rm <file> = svn rm <file>

	git commit -a -m "message" = svn commit -m "message"
		NOTE: only changes commited to local/private repo
		-a == automatically stage files that have been
			modified and deleted, but new files you have not told Git about are not affected
			with this option you dont need to stage (add) before committing
			and/but everything is staged together
		-m message required
			without it, preferred editor is launched
			to change editor, look below in git config section

	git push
		publish all changes in local repo to remote/public repo
		unlike in SVN, usually you will nedd
			git commit ...
			git push

	git status = svn status
		VERY IMPORTAT: use it every time
		is there sth to commit?
		are there conflicts?
		the branch we're in is displayed also

	git mv <old file> <new file> = git mv <old file> <new file>

	git log = svn log | less
		all commits & messages shown in reverse chronological order
		each commit has a hash (id) + author + date + message
		history check
	git log --oneline
		hash + commit message only
	git log --oneline --graph --decorate --all
		graph displayed

	git log --stat
		additional info: files + line + summary
	git log -p [SHA]
		files modified + location + changes
		if we pass the SHA hash, e.g. fdf54
			we see the infor of that commit
	git show <SHA>
		information of a commit: commit, author, date, etc.

	git pull = svn update
		get from remote repo all changes
		IMPORTANT: pull always before pushing!

	git diff = svn diff | less
		inspect local changes
		only files that were already added to repo are analyzed
	git diff <file>
		show differences between local copy of file and reference
		reference file is the last commited = HEAD
		UNstaged changes are diffed (the ones that were not added yet)
			see git add to understand what's staging
		notation:
		+ added line wrt last added
		- removed line wrt last added
	git diff --cached <file>
		STAGED files are diffed	
	git diff [<options>] <commit> <commit>
		diff between 2 different commits (commit hash used? see git log)
	git diff <hash> HEAD
		compare a commit with HEAD
		to get hash ids:
			git log --oneline
	git difftool <hash> HEAD
		same as before, but GUI launced

	git help
		help / menu
		it is also displayed with 'git'

	git help <command>
		example: git help add, git hekp diff
		browser is opened with docu/reference

## Teamwork: branches & merges

	In contrast to SVN, git doesn't use folders to manage branches.
		In git, you have only one local copy of the repo.
	In git, we're always working on a branch!
		HEAD branch: the branch we are in or branch of last commit
			sometimes it's the master branch, but that's a bad practice
			usually, nobody sould work on the master
			everybody should work on a branch and merge it gradually to the master

	git branch <new-branch>
		CREATE new branch
		every newly created branch is a copy of the branch we are in
		alternatively, in JIRA, go to repo and click on button 'create new branch'
		IMPORTANT NOTE: if we create a branch locally with the CLI, we need to push it upstream, as explained below:
			git push [remote] [branch]
				remote = origin (default)
				branch = our local branch we newly created, eg, develop
			git push --set-upstream origin develop
			git push -u origin develop
				--set-upstream == -u

	git checkout <other-branch>
		SWITCH to a different other-branch within our local copy of the repo
		IMPORTANT: checkout here is not like in SVN! Were are switching branch!

	git checkout -b <new-branch>
		CREATE a new branch and SWITCH to it
		equivalent to
			git branch <new-branch>
			git checkout <new-branch>
		probably the most used alternative is git checkout -b

	git branch
		LIST all available LOCAL branches

	git branch -a
		LIST all available branches

	git branch -d <branch-to-delete>
		DELETE a branch

	git checkout TAB
		see all possible branches

	git merge --no-ff <other-branch>
		first we switch to the branch to which we want to merge things
			git checkout master
		then we merge other-branch to the branch we are in (master)
			git merge other-branch
		current branch is merged with other-branch
		--no-ff = no fast forward, create a new commit and preserve history
		if a merging conflict occurs, git separately handles teh conflicting files
		after resolving manually the conflicting files, they are added with
			git add <file>
		and commited
			git commit -m "my message"
	git mergetool
		a GUI is launched
		we can do the same as before but see a visual merge

	git fetch
		if you want to download & inspect remote changes before integrating them
		later, you can integrate it with gitmerge
		'git pull' does 'fetch' and it downsloads and tries to merges

	git push [remote] [branch]
		publish all changes
			BUT: beforehand the local repo must have been linked to online repo
				git remote add origin <URL>
		remote & branch are necessary usually first time or when something changes
			otherwise it's enough to use: git push
			remote: the name of the remote repository, usually origin
			branch: branch name in the remote repository
				to which we are pushing our current local branch
		example:
			remote name: origin
			branch name: master
			-> git push origin master
				push your local changes to your online repository
		NOTE: if we try to push our current branch which does not exist online yet
			we get an error/warning
			and we need to set it upstream (= publish it online)
			example:
				local branch: develop
				remote repo: origin
				remote branches: master
				to add local branch develop:
					git push --set-upstream origin develop
					git push -u origin develop
						--set-upstream == -u

## Creating a new repository locally

	Commands (executed on a local folder):
		cd desired_folder
		git init .
			with that, we have our local version control! :)
			.git/ created for storing database
			GOOD PRACTICE: create at the beginning always (although left empty):
				.gitignore
				README.md
			vim myfile.txt, edit, :wq
		git add .
			everything in folder added
		git commit -m "Initial commit"

	What it does:
		gitinit creates anew empty repo in the current folder
		gitadd marks the currrent contents of the folder for the next commit
		gitcommit commits the marked contents to the local repo

	Uploading to an online platform, eg Github
		Create the online repo and add our desired branch to it
		See below (create a repository in Github) and also above (git push)
		Example
			git remote add origin https://github.com/mxagar/my-repo.git
			git push origin master

## Admin / Management of repos

	Change remote URL

		git remote -v
		# View existing remotes
		# origin  https://github.com/user/repo.git (fetch)
		# origin  https://github.com/user/repo.git (push)

		git remote set-url origin https://github.com/user/repo2.git
		# Change the 'origin' remote's URL to repo2

		git remote -v
		# Verify new remote URL
		# origin  https://github.com/user/repo2.git (fetch)
		# origin  https://github.com/user/repo2.git (push)

	Change from HTTPS to SSH

		If we clone a repository as HTTPS but
		need to keep using it as SSH/GIT, we need to change the remote URL
		This is equivalent to the line above

		git remote set-url origin git@github.com:user/repo.git
			change the git@github address by the one shown when cloning per SSH

## Git tags

	we can mark points as milestones: tags
	eg, with release versions
	there are 2 types of tags
		lightweight: pointers to a specific commit
		annotated: full objects with more info

	Listing tags
		git tag
			list all tags
		git tag -l "4.*"
			list all tags starting with "4."

	Checking out tags
		
		git checkout <tagname>
			we check out a tag
			BUT, if we commit a change, the tag doesnt change!
			this makes sense when we want to checkout a tag of a 3rd party library
		git checkout tags/<tag> -b <branch>
			we checkout a tag to a (new) branch
			when we commit changes, we modify our new branch, the tag remains the same
				we would have to create a new tag?
			thi smakes sense when we are creating our own tags with our library/code

	Creating tags
		
		git tag -a <tagname> -m "my version tagname"
			create a new annotated tag
		git show <tagname>
			show infor of the tag
		git tag <tagname>
			create a new lightweight tag

	Sharing/Pushing tags

		git push origin <tagname>
			we publish the new tag in our local repo to the remote public repo
			note that 'git push' alone doesnt do that!

	Deleting tags
		
		git tag -d <tagname>
			we delete tag, but only localy, not from remote server
		git push origin --delete <tagname>
			we delete tag also in remote server

## Git configuration

	git config --global user.name "John Doe"
		the option --global stores the config in ~/.gitconfig
		--system would store it in /etc/gitconfig and would apply to all users
		--local in .git/config
	git config --global user.email johndoe@example.com
	git config --global core.editor vim
	git config --global user.signingkey <gpg-key-id>
	git config --list

## Github: Intro

	Repositories vs Projects
		Repositories: the traditional repositories of versioned code
		Projects: project boards to organize work, linked to a repo/s

	Create a repository in Github (online)
		Crate an account: mxagar
		Click '+' button > new repository
		Name: my-repo
		Select: public / private
		Click create repository

		Setup: 4 alternatives, shown on Github
		1) Clone online empty repository to local folder

			git clone https://github.com/mxagar/my-repo.git

		2) Create first a local repository and then push it to the online repo
			
			(see creating a new repo)

			git init
			vim README.md
			vim .gitignore
			git add README.md .gitignore
			git commit -m "first commit"
			git remote add origin https://github.com/mxagar/my-repo.git
			git push origin master

		3) Push an existing repository from command line

			(same last two lines as before)

			git remote add origin https://github.com/mxagar/my-repo.git
			git push origin master

		4) Import code from another repository (eg, SVN, Mercurial, etc.)

		IMPORTANT NOTES
			- Only one branch is uploaded when linking a local repo to an online
				usually:
					local repo: our folder
					online repo: origin
					local branch: master
					online branch: master
					-> git push origin master
			- If we create a new local branch, we need to publish it! (aka set upstream)
				example
					local repo: our folder
					online repo: origin
					local branch: develop
					online branch: develop (it's created)
					-> git push --set-upstream origin develop

	Account in Github: Fetaures and how to use it
		Overview of contributions
		Profile: email, web
		Repositories
		Projects
		...

	Repositories in Github: Features and how to use them
		Code
			commits
				select one
				click on hash
				commets can be done
					for whole commit
					for each line!
			branches & branch selector
				with branch selector a new branch can be created!
			new pull request -> see pull request
		Issues
		Pull requests -> see pull requests
		Projects
		Wiki
			only for Pro or public repos
		Settings
			many things
			you can delete repo here
				options
				scroll down: Danger Zone

	Pull requests (in Gitlab: merge request)
		Usual workflow
			(fork)
			create branch from base branch (master)
			work on branch
			create pull request
				main idea: we are asking to merge our branch to the base (master)
				assign reviwers + assignee
				message
					use @mention
			responsible colleagues comment and analyze
				they have a new pull request in their respective tab
				they comment changed files/line
				the responsible merges and closes the conversation
				the branch can now be deleted (there's a button for that)
			responsible merges branch to base

	Alternatives to Github
		GitHub Pro (not free)
		GitLab (free & not free)
		Jira Atlassian (free & not free)

## Markdown syntax / README.md

	Contents: project name + how to install & dependencies + how to use + contact info
	Usual name: Readme.md
	Tool for checking our Markdown text
		https://dillinger.io/

	MarkdownExample.md

		# Basic Syntax

		# Heading level 1, H1
		## H2
		### H3

		This is normal text.
		**bold text**
		*italicized text*
		_italicized text_	
		~~strikethrough~~
		__underline__
		> blockquote
		1. First item
		2. Second item
		3. Third item
		- First item
		- Second item
		- Third item
		`code`
		---
		[title](https://www.example.com)
		![alt text](image.jpg)

		# Extended Syntax

		## Tables
		| Syntax | Description |
		| ----------- | ----------- |
		| Header | Title |
		| Paragraph | Text |

		## Fenced code block
		```
		{
		  "firstName": "John",
		  "lastName": "Smith",
		  "age": 25
		}
		```

		## Fenced code block with syntax highlighting
		```python
		while(True):
			pass
		```

		## Footnotes

		Here's a sentence with a footnote. [^1]

		[^1]: This is the footnote.

		## Heading ID

		### My Great Heading {#custom-id}

		## Definitions

		term
		: definition

		## Task list

		- [x] Write the press release
		- [ ] Update the website
		- [ ] Contact the media

		## Links to files and sections

		Files should appear as links: [File](file.md)
		README sections should appear as anchor links: [Links to files and sections](#links-to-files-and-sections)

		## Collapsable text

		For some amazing info, you can checkout the [below](#amazing-info) section.

		<details><summary>Click to expand</summary>

		## Amazing Info
		It would be great if a hyperlink could directly show this title.

		</details>

	Badges

		https://shields.io/#your-badge
		Example
			[![Unfinished](https://img.shields.io/badge/status-unfinished-orange)](https://shields.io/#your-badge)

## CFG Files: Configuration files

	basically, we have configuration files that contain structures (objects) with their key-value pairs
	keys are variable name strings
	values can be
		strings
		ints
		floats
		arrays/lists of the previous

	I have seen the format in Deep Learning, as a way to describe an architecture by listing its layers (objects)

	example.cfg

		# This is a comment

		# Instance of object1: parameter values as key-value pairs
		[object1]
		key1=value1
		key2=v1,v2,v3

		# Instance of object2
		[object2]
		key3=value2

## Udacity Github Good Practices

	general points
		nice pic
		contact info
		at least 3 own projects
			clear project desription
		starred/fav projects
		regular contribution
		nice readmes
	
	https://career-resource-center.udacity.com/linkedin-github-profiles/become-a-github-pro

	How to write readmes
		tutorial style
		short getting started examples
			usage examples
			should get user ready as fast as possible
		short clear sections
		short simple sentences
		links to further information
		license!

	Anatomy of a readme
		Title
			Short description
		Installation / Getting Started
			Dependencies
			Installation commands
		Usage
			Commands
			Known bugs
		Contributing
			Guidelines if people wantto contribute
		Code Status
			are all tests passing?
			shields: build/passing
			if necessary
		FAQs
			if necessary
		License / Copyright
			By default, I have the intelectual property, but it's not bad stating it explicitly if necessary
			Choose appropriate license

	Markdown 101
		Syntax explained
		Look at my Markdown section

	Commit messages: Best practices
		https://udacity.github.io/git-styleguide/

		Structure according to Udacity Style Guide
		<type>: <Subject>
			type
				feat: a new feature
				fix: a bug fix
				docs: changes to documentation
				style: formatting, missing semi colons, etc; no code change
				refactor: refactoring production code
				test: adding tests, refactoring test; no production code change
				chore: updating build tasks, etc; no production code change
			Subject: 50 chars max
				start capital, use imperative, no . at the end
		[<body>]
			optional
			longer text paragraph after space, but as concise as possible
			bullet point can go here
			not all commits require one

		[<footer>]
			optional
			indicate which issues or bugs the commit addresses

	Open Source Projects: How to contribute to them?
		Udacity encourages contributing to Open Source projects
		Possible starting points
			Select favourite projects
				select them to watch
				start repositories
			Clone and compile them
			If any issues during getting started, post issues
				Readme could be extended?
				Is somtheing unclear? 
				Version dependency issues?
				DOCUMENTATION is a goo start point
			Go through current issues
				DOCUMENTATION issues are a good start
				You can fix the documentation and make a PULL REQUEST

	Good practices
		Commit at least once per week
		Nice readmes
		Nice commit comments
		Watch & star projects
			languages you like
			libraries you use
			interesting works
		Contribute to open source projects

## Tips & Tricks & Issues

	To show
	'user@host folder (branch)'
	in a BASH Terminal prompt: modify/add the following:
		~/.bash_profile
		# Git branch in prompt.
		parse_git_branch() {
		  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
		}
		export PS1="\u@\h \W\[\033[32m\]\$(parse_git_branch)\[\033[00m\] $ "
		source ~/.bash_profile

	in a ZSH Terminal: add the following:
		~/.zshenv
			# Load version control information
			autoload -Uz vcs_info
			precmd() { vcs_info }
			# Format the vcs_info_msg_0_ variable
			zstyle ':vcs_info:git:*' formats 'on branch %b'
			# Set up the prompt (with git branch name)
			setopt PROMPT_SUBST
			PROMPT='%n in ${PWD/#$HOME/~} ${vcs_info_msg_0_} > '		

	Submodules
		sometimes, inside a git project, there is another git project: these are submodules
			commmits to submodules are kept separate
		if you want to add a submodule, for example:
			git submodule add https://github.com/chaconinc/DbConnector
		if you clone a project with a submodule, you need to
			git submodule init
			git submodule update

	Windows

		Access Denied Upon PW Update
			everytime we change the Windows PW, we need to update the Git credentials
			otherwise we get the error 'HTTP Basic: Access Denied'
			to update credentials
				Windows key
				type 'credential'
				Credential Manager
				Windows Credentials
				Update the PW of Gitlab/Gitlab
			more info
				https://stackoverflow.com/questions/47860772/gitlab-remote-http-basic-access-denied-and-fatal-authentication

	Get repository URL
		cd folder
		git config --get remote.origin.url
		

	Change remote URLs from HTTPS to SSH, or vice versa
	Change the remote URL after forking/transferring/renaming

		example:
			we are connected to:
				https://github.com/user/my-project.git
			we want to connect to:
				git@github.com/user/my-project.git

		cd .../git_repositories/my-project
		git remote -v
			list exsiting remotes
			the https URL above should be there
		git remote set-url origin git@github.com/user/my-project.git
			the remote is changed
		git remote -v
			the git/SSH URL above should be there

		Note:
		We can also add a remote instead of replacing it

			git remote add upstream git@github.com/user/my-project.git
			git remote -v
			git fetch upstream
				for getting metadaaata from  all remotes: git fetch --all

		NOTE: to see the conversion from SSH keys to access token, see section "Access Tokens"!

	Deal with .DS_Store correctly = ignore it

		https://gist.github.com/lohenyumnam/2b127b9c3d1435dc12a33613c44e6308

		If .DS_Store was never added to your git repository,
		simply add it to your .gitignore file

			.gitignore
				.DS_Store
				**/.DS_Store

		If it's already there

			find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch
			git commit -m "Remove .DS_Store from everywhere"
			git push


	I accidentaly deleted a file and I want it back

		git log --oneline
			Check the SHA strings of the commits and the messages;
			select the SHA you want
		git show <SHA>:/path/to/file > file
		git show 9dfg56:my_important_file.txt > my_important_file.txt
			file from the previous commit is piped to local file
		git add my_important_file.txt
			we add it again

	I accidentally added a large file and I'd like to remove it

		https://saiankit.medium.com/how-to-remove-large-files-that-you-have-wrongly-committed-in-git-3358a95f1fe9

		cd root/path
		git filter-branch --tree-filter 'rm -rf path/of/large/file' -f HEAD
		git stash save
		git push origin master --force
			or main

	How to Use conda in Git Bash (Windows)

		Open Explorer in 
			C:\Users\msagardi\AppData\Local\anaconda3\etc\profile.d
		Right click on folder
			Open Git Bash Here
			echo ". ${PWD}/conda.sh" >> ~/.bashrc
		Open a new Git Bash instance: we have conda access!

		Source:
			https://discuss.codecademy.com/t/setting-up-conda-in-git-bash/534473


## SSH Authentication
	
	The SSH authentification method takes a little configuration time
	but then it saves time, because HTTPS requires username+pw for every change we upload; now it's compulsory to use SSH it on Github
	For it, we need SSH key
		SSH keys are like passwords

	Note: Encryption mechanisms
		symmetric vs asymmetric
			symmetric: bi-directional, same algorithm and key can be used for both encryption aand decription
				symmetric keys used by SSH to encrypt the entire connection
			asymmetric: like hashing, the hash identifies original data, but cannot be used to retreive the original data
				SSH uses these for authentification
		algorithms
			public key cryptography algorithms -> for reliable authentication
				key pairs: public + private key
				algorithms used: RAS, DSA, ECDSA
			data integrity protection algorithms -> for data integrity protection
			symmetric cypher algorithms -> protection of data privacy

	Github: how to create and add an SSH key (also equivalent for Gitlab)

		https://docs.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent
	
		https://docs.gitlab.com/ee/ssh/

		Mac
			Check existing keys
				ls -al ~/.ssh
					github_mxagar
						a private key, usually encrypted with a pw (eg, same pw as for Github)
					github_mxagar.pub
						a public key
					known_hosts
					config
			Generate a new key if needed
				ssh-keygen -t ed25519 -C "mxagar@gmail.com"
					ed25519 used in this case, we can use also RSA, etc.
				Enter filename
					eg, github_mxagar (private key name)
				Enter encryption pw twice
					eg, same pw as for Github
					private key is encrypted with it
			Add to ssh-agent
				eval "$(ssh-agent -s)"
					some process must be running...
					Agent pid x
				make sure ~/.ssh/config exists; if not create it
					touch ~/.ssh/config
				add to ~/.ssh/config
					vim ~/.ssh/config
						
						# Github.com
						Host github.com
						  IgnoreUnknown AddKeysToAgent,UseKeychain
						  AddKeysToAgent yes
						  UseKeychain yes
						  IdentityFile ~/.ssh/github_mxagar

						# Github.com Windows
						Host github.com
						 Hostname github.com
						 IdentityFile ~/.ssh/id_ed25519

						# GitLab.com
						Host gitlab.com
						  IgnoreUnknown AddKeysToAgent,UseKeychain
						  PreferredAuthentications publickey
						  IdentityFile ~/.ssh/gitlab_mxagar

						# Gitlab Telekom
						 Hostname gitlab.devops.telekom.de
						 User git
						 IdentityFile ~/.ssh/id_ed25519_telekom
  
				add key to the ssh-agent
					ssh-add -K ~/.ssh/github_mxagar
					ssh-add -K ~/.ssh/gitlab_mxagar
					# Windows, -K does not work?
					ssh-add ~/.ssh/github_mxagar
					ssh-add ~/.ssh/id_ed25519
					ssh-add ~/.ssh/gitlab_mxagar
					ssh-add ~/.ssh/id_ed25519_telekom
						enter encryption pw, eg, Github pw
						note: I use the same Github passphrase for all...

				maybe, we need to...
					create known_hosts
						touch ~/.ssh/known_hosts
					connect once to github:
						ssh git@github.com
						ssh git@gitlab.devops.telekom.de
					and add the fingerprint: yes

				... and then clone the repo, after the public SSH key has been added to Github/Gitlab

			Add SSH public key to Github/Gitlab

				Profile icon > Settings > SSH & GPG Keys > New SSH key
				Copy and paste the contents from
					github_mxagar.pub / gitlab_mxagar.pub
				Enter pw, ie, the pw used to encrypt the private key, eg, the Github pw

		Windows

			Process is similar/equivalent with the Git-Bash command prompt
				Look for instructions on Github page online
					https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent?platform=windows
				Git-bash GUI can be used also: Help > SSH keys...
			However, it is possible to do it with Windows GUIs
				For SSH key generation Puttygen can be used
					Select RSA / Ed25519
					Generate
						move mouse for entropy
					Save private and public key in a known place
						equivalent to ~/.ssh/
				Go to a repository
					left click > TortoiseGit > Settings
						Git > Remote: origin
						URL: we might need to change the HTTPS address to the GIT address
						Putty Key: add the PRIVATE key we saved

	Github/Gitlab: Personal Access Token

		https://knasmueller.net/gitlab-authenticate-using-access-token

		See also next section!

	Pushing to HTTPS repositories: Personal Access Tokens

		Since August 2021 it's not possible to push to HTTPS repos
		using the username & pw; instead GIT repos must be used
		with the SSH authentication explained above.

		HOWEVER, it is still possible to push to HTTPS repos
		using PERSONAL ACCESS TOKENS.

		Steps:

		- Create a token on Github: Github Settings > Developer Settings > Personal Access Token: Create
		- In the notebook instance terminal, set user account and activate credential storing:

			```bash
			# Open Terminal and set user account
			git config --global user.email "mxagar@gmail.com"
			git config --global user.name "mxagar"

			# Activate credential storing to local file
			# If we use 
			#   credendial.helper cache
			# instead of
			#   credendial.helper store
			# the credential (token) is saved to memory
			git config --global credential.helper store

			git pull

			# Edit something
			git add .
			git commit -m "message"
			git push
			# Input
			# - username
			# - pw: token

			# Check that the credential is there!
			# If we chose 'store', it should be there
			less ~/.git-credentials
			```

		Later on, to push, either do it in the Terminal, or using the GUI: left menu panel, Git icon.

		Note that with the option `credendial.helper store` a file is stored with our credentials, without encryption!

		See also next section!

## Access Tokens

	In some cases we cannot use SSH keys, but access tokens are required.
	To that end, we create the token in the Web UI and copy it locally.
	Then, we can clone the repo using the token

        export GITLAB_ACCESS_TOKEN=xxx
            Get the Personal Access Token on the Gitlab Web UI

        git clone https://oauth2:$GITLAB_ACCESS_TOKEN@gitlab.repo-url.de/repo.git

    Now, if we list the remote URLs, we should see the URL with the token

        git remote -v
            we should get https://oauth2:xxx@gitlab.repo-url.de/repo.git

    Since the token is in the URL, we can work with the repo and git
    as always, without needing to add any further credentials!

    	change files
    	git add .
    	git commit -m "msg"
    	git pull git push

    To MIGRATE FROM SSH KEYS TO ACCESS TOKEN, we simply need to
    create the acess token and change the remote URL!

        git remote -v
            we should get git@gitlab.repo-url.de/repo.git

        export GITLAB_ACCESS_TOKEN=xxx
            Get the Personal Access Token on the Gitlab Web UI
                    
        git remote set-url origin https://oauth2:xxx@gitlab.repo-url.de/repo.git

    Now, we work as always!


## Social Coding: Fork, Change on Branch, Pull Request
	
	Note: in Gitlab a 'pull request' is a 'merge request'

	The usual steps are
		1. fork a project
		2. work on it on our own branch downstream
		3. make a pull request to merge our changes upstream
			a pull request is a request to the 3rd party online repo
			to integrate your changes
		4. update the PR is necessary
		5. the original developer accepts the PR and merges it
		6. the developer that forked and made the changes synchronizes the merged changes

	Also
		7. we need to manage collaborators

	1. Forking
		log in to github
		go to project we want to fork
		click on "fork" button up right
		the project is cloned to our profile

	2. Working on the project
		clone the forked project to our local machine
			cd .../git_repositories
			git clone URL
		make a new branch and change to it
			git checkout -b 
		work on the project
			add, modify, commit, etc.
		push branch upstream to our remote repository 'origin'
			git push -u origin new-feature

	3. Pull Request (in Gitlab: merge request)
		After the new branch with changes is uploaded on our remote online repo
			go to Github page of repo
			select new branch with changes
			click on "Compare & Pull Request"
				base fork: 3rd party online repo I forked from 
				base: 3rd party branch I forked
				head fork: my online repo where I forked to
				compare: my online banch where I made changes

				'compare' is going to be compared to 'base'

			click on "Create Pull Request" 	
				the pull request (PR) lands on the 3rd party project

				a pull request is a request to the 3rd party online repo
				to integrate/merge your changes

	4. Updating Pull Requests

		we go to the repo on Github
		and click on the menu "Pull Requests"
		we see the PRs with
			title
			id
			commits done to eahc
			conversation
			changes/diffs
			we can assign
				people/accounts
				labels
				milestones
		we can continue adding commits!
			and they appear in the section


	5. Accepting Pull Requests

		we need to have write-premission to accept a pull request
		the view is very similar as before: we click on menu "Pull Requests"
		we can add review comments under each PR
		we see for each PR the same features
			title, id, commits, ...

		we can add comments on the code differences we see on Github!
			the comments are literally in the lines!
		it is very important to review PRs!

		Github lets us know if a PR can be automatically merged!
			if so, we click on button
			we can always click on "Reverse" button later

		Once merge has happened
			the account that made the changes and the PR
				sees the PR was accepted and merged
				he/she sees the "delete the branch" option
					and can click on it
					to remove the branch where the changes where made
			the PR status changes to closed

	6. Synchronize changes back to the fork

		let's say we have these repos
			ninja-user/project
				upstream repo
				it was forked by new-user
				and PR merged by ninja-user to 'master' branch
			new-user/project
				downstream repo where changes were made in 'new-feature'
				new-user wants to synch it with the merged upstream repo

		Terminal by new-user/project

			git status
				check status
			git checkout master
				checkout master branch
				BUT: here, we take our forked master, not the one with merges!
			git remote -v
				we see all our remote repos for fetch/pull
				which usually will be 'origin';
				now, we need to add the remote URL of ninja!
				for that we go to ninja-user's profile
				and copy to clipboard the cloning URL
					git@github.com:ninja-user/project.git
			git remote add upstream git@github.com:ninja-user/project.git
				we add a remote repo called 'upstream'
				which is pointing to the 3rd partty original repo online
				that has the merged changes
			git remote -v
				now, we should have two remote repo URL
					'origin' (ours)
					'upstream' (3rd party's)
			git pull upstream master
				now we download the changes from ninja-user's master
				which has themerged changes
			git push origin master
				and we push the donwloaded chnages to our forked repo
			git branch -a
				show all our branches, local and remote
				we need to clean up the branch we used for the changes
					'new-feature'
			git branch -d new-feature
				delete the banch we used for the changes
			git branch -a
			git fetch -p
				any unnecessary branches are prunned

	7. Managing collaborators

		we can give write permision to users
		go to repo page on Github
			... / Settings
			Manage access
			Invite a collaborator: name, email, username, etc.


## Updating an upstream repository into your fork

	https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/merging-an-upstream-repository-into-your-fork

	# Go to local repo
	cd ~/git_repositories/my_repo
	
	# Checkout the branch we'd like to merge to
	# in case we're in another branch;
	# we might be already in that branch: master,
	# so this step can be skipped
	git checkout BRANCH_NAME

	# Pull from the upstream repo we forked
	# Note: select the branch we'd like from that upstream repo
	git pull https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git BRANCH_NAME
	git pull git@github.com:ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git BRANCH_NAME

	# Address any merge conflicts we might have:
	# See next section

	# Push to the remote repo branch we'd like;
	# if we're in that branch locally, we can simply
	# git push
	# else:
	git push origin BRANCH_NAME

	Note: however, we'll see a button in the GitHub.com web GUI, too: "Fetch upstream"; so this can be done by clicking on the GUI.

## Merge conflicts

	# Go to local repo
	cd ~/git_repositories/my_repo

	# Get conflicts, in red;
	# We need to go one by one, and for each filw either:
	# - git rm the file
	# - modify the file and git add
	git status

	Conflicts have this appearance
		If you have questions, please
		<<<<<<< HEAD
		open an issue
		=======
		ask your question in IRC.
		>>>>>>> branch-a

	The part
		<<<<<<< HEAD
		...
		=======
	is the part of the HEAD

	The part
		=======
		...
		>>>>>>> branch-a
	is the part of the other branch

	Which part part do we want?
	Select the desired one and remove the other
		together with the >>>, <<<, === separators


	git add .
	git commit -m "Resolved merge conflict."

## Github Issues

	Issue tracking on Github is basic, but useful.
	We select a project and click on "Issues" menu.
	If we click on "New issue"
		we can add titile + text
			Markdown
		assignee
		label:
			bug / documentation / enhancement / question / ...
			we can also create labels
		projects
		milestone:
			we can create date-based milestones, eg, beta 1, beta 2, etc.
		link PRs
	Later on, we can have a conversation in the issues, close them, etc.

	We can associate commits with issues and even close them!
		Say we have an issue with id #4
		We do our changes locally and commit + push
			git pull
			... (changes) ...
			git commit -m "fixed bug, close #4"
				now, in the issue #4, commit is associated and issue closed!

## Github Gists

	Gists are a way to share code: entire files or snippets
		it's a mini-repository
		we can  use them as a git repo: clone, pull, push, etc.
		people seem to use it for snippets

	Plus icon -> New gist
	Click on badge icon -> Your Gists
		we can create public or private gists
		each gist has a unique URL which can be shared
			the URL can be compress, eg with bitly

## Github Organizations

	Organizations are not necessarily companies
	but groups of repos or people working together

	Plus icon -> New organization
		we add description & co.
		we can add users
		we can add repos
			or we can transfer our personal repos to orgs!

	We can switch personal page / orgs with image icon

	Transferring a repo to an org
		go to our user page
		select a repo
		go to repo settings (in ... icon)
			scroll down to danger zone
			Transfer ownership
				follow steps

		after transferring, the best practice
		is to fork back the repo to our personal account

		Note that if we work on the forked version,
		we need to merge it later;
		otherwise, we could also work on the repo of the organization!

	Teams

		in a organization we have a tab/menu for defining teams
		we can add members to teams and define permissions for a team
			eg, Developers
		we can invite members and make them owners of the org
			an owner has all priviledges
		we need to add the repos associated to a team
			and in th eprocess, we set permissions: admin / write / read

	Have a look at the org settings page, many things can be done...

## A successful Git branching model

	A very interesting article on how to work with branches on teams: [A successful Git branching model](https://nvie.com/posts/a-successful-git-branching-model/). My notes on it:

	- `origin/master` should be always production-ready
	- When `develop` is steady, it's merged to `origin/master`
	- Besides `master` and `develop`, we have other branches with limited lifetime, ie., unlike `master` and `develop`, they'll be removed eventually:
		- Feature branches: `feature-*`
			- To work on new features
			- They are branched from `develop`
			- When development finished, they are merged to `develop`; then deleted!
		- Release branches: `release-*`
			- To support releases: few new things implemented, since these are done in the feature branches
			- They are branched from `develop`
			- When development finished, they are merged to `develop` and then to `master`
			- After merging to the `master`, a `tag` is created with the release version with the major minor notation, e.g., `1.2`
		- Hotfix branches: `hotfix-*`
			- Like release branches, but done to fix unplanned bugs; thus, the workflow is similar
			- They are branched from `develop`
			- When development finished, they are merged to `develop` and then to `master`
			- After merging to the `master`, a `tag` is created with the last release version + the hotfix patch number, e.g., `1.2.1`

## Workflow: Working on Teams

	Usual workflow explained with an example: we are working on a recommendation engine; first we want to improve the recommenddations with demographics data; then, we are asked whether we can improve it with information about friends groups.

	- There should be always two major branches up in the cloud or remote: `master` or `main` and `develop`.
	- `develop` should contain the latest stable version from which we check out to work.
	- For each new feature we are creating, we create a local branch, say `feature-demographic`
		- We commit our work related to that feature to our local branch
	- If we are requested to work on a new feature, we check out from the `develop` in the cloud/remote and create a new local branch, say: `feature-friends`
		- We commit our work related to that feature to our local branch
	- When we finish a feature:
		- If we don't have W permissions for the cloud/remote `develop`
			- We make a pull request
			- A code review is done
			- We modify our code according to the reviews
		- The `feature-` branch is merged to the `develop` branch
	- After the team reviews the changes in `develop`, they merge them locally to `master`, and the local `master` is pushed to the cloud `master`, which should be production-ready.

	```bash

	## 1) we start to work on a first feature

	# switch to develop branch
	git checkout develop
	# pull latest changes
	git pull

	# create and switch to a new local branch
	git checkout -b feature-demographic
	# work on this local repo
	git add ...
	git commit -m "..." # always commit before changing branches!
	# optionally, we can push to the cloud/remote repo if we want other to see it
	git push # we'll get an error with the right command: copy & paste
	git push ... # git push --set-upstream origin feature-demographic

	## 2) now, we are requested to work on a second feature

	# switch to develop branch again to create a new local branch!
	git checkout develop
	git pull # always pull changes from develop!

	# create and switch to yet another new local branch
	git checkout -b feature-friends
	# work on this local repo
	git add ...
	git commit -m "..." # always commit before changing branches!
	# optionally, we can push to the cloud/remote repo if we want other to see it
	git push # we'll get an error with the right command: copy & paste
	git push ... # git push --set-upstream origin friends

	## 3) we finish the second feature

	# switch to develop
	git checkout develop
	# merge our second feature to develop locally
	# --no-ff = no fast forward, create a new commit and preserve history
	git merge --no-ff feature-friends
	# push local develop to cloud/remote; origin is by ddefault the name of the remote repo
	git push origin develop # if in teams with branches, specify where to push!

	# 4) we continue with our first feature

	# switch to branch
	git checkout feature-demographic

	```

## Workflow: Fork-Branch-Pull-Request

	I found the following interesting article:

	[The Git Fork-Branch-Pull Workflow](https://www.tomasbeuzen.com/post/git-fork-branch-pull/)

	To properly understand and test the workflow, I tried it. It covers:

	- Forking foreign repos
	- The Branching & Pull-Request Workflow introduced so far above, but applied to the forked repo.

	![Fork-Branch-Pull Workflow](fork-branch-pull-worrkflow_tomas_beuzen.png)

	First steps:

	- I created an organization (free): GitHub, +, New Organization: `machine-vision-academy`.  
	- I created a repo in it: `mv_toolkit`: [https://github.com/machine-vision-academy/mv_toolkit](https://github.com/machine-vision-academy/mv_toolkit)
	- I forked it to [https://github.com/mxagar/mv_toolkit](https://github.com/mxagar/mv_toolkit)

	Note that the remote repo URLs are:

	```
	git@github.com:machine-vision-academy/mv_toolkit.git
	git@github.com:mxagar/mv_toolkit.git
	```

	Both repos have `master` and `develop`. Recall that when we fork, there are two remote repos: OURS (aka **origin**) an THEIRS (aka **upstream**). If we want to pull a branch from THEIRs to OURs, we can do it in two steps: first we pull to our local repo, then we push it to OUR cloud/remote repo:

	```bash
	# Go to local repo
	cd ~/git_repositories/my_repo

	# Checkout the branch we'd like to merge to
	git checkout BRANCH_NAME # git checkout -b BRANCH_NAME

	# Pull from the upstream repo we forked
	# Note: select the branch we'd like from that upstream repo: 
	git pull https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git BRANCH_NAME
	git pull git@github.com:ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git BRANCH_NAME

	# Push to OUR remote repo branch we'd like
	git push --set-upstream origin BRANCH_NAME
	```

	Note: however, we'll see a button in the GitHub.com web GUI, too: "Fetch upstream"; so this can be done by clicking on the GUI.


	##### Step by Step Workflow

	Summary of cloud/remote repos and branches:

	```
	git@github.com:machine-vision-academy/mv_toolkit.git (original, THEIRS)
		machine-vision-academy:mv_toolkit - master
		machine-vision-academy:mv_toolkit - develop
	git@github.com:mxagar/mv_toolkit.git (forked, OURS)
		mxagar:mv_toolkit - master
		mxagar:mv_toolkit - develop	
	```

	I carried out these steps, following the [link](https://www.tomasbeuzen.com/post/git-fork-branch-pull/) form above:

	```bash
	# Go to local repo, which points to OUR cloud/remote repo
	cd ~/git_repositories/mv_toolkit

	# Check the cloud/remote repo
	git remote -v # origin: git@github.com:mxagar/mv_toolkit.git (fetch/pull, push)

	# Add remote called "upstream" pointing to the original repository (THEIRS)
	# Now we'll have 2 remote/cloud repos: origin (OURS) and upstream (THEIRS)
	git remote add upstream git@github.com:machine-vision-academy/mv_toolkit.git
	git remote -v

	# Create and checkout a new branch called "feature-test":
	git checkout -b feature-test

	# Make the desired changes to the local repository on this branch
	vim README.md
	# Edit, ESC :wq
	git add .
	git commit -m "Minor changes in README"

	# Pull changes from the original remote branch we want to merge to
	git checkout develop
	git pull upstream develop

	# Merge locally our feature-test (where we are) to develop
	git checkout feature-test
	git merge --no-ff develop

	# Push changes to remote/cloud origin (OURS)
	git push origin feature-test

	# Open a Pull Request on upstream remote:
	# (base) upstream:develop <- (head, compare) origin:feature-test
	# Steps:
	# - Go to GitHub, OUR remote repo (origin)
	# - Navigate to "feature-test" branch
	# - "Compare & pull request"
	# - "Create Pull Request"
	# Then, the OTHERS would accept the PR
	# In this case, I'm the OTHERS, too, with the MVA organization.
	# Typically, they:
	# - Review
	# - Wait for checks in the web GUI, then "Merge" and "Confirm"
	# However, we can get change requests back.

	# After Pull Request has been accepted and merge by the OTHERS
	# Update our local repos with the remote/cloud ones
	git checkout develop
	git pull upstream develop

	# Since I use a double master-develop structure in MVA
	# I create a PR and merge in the upstream remote develop->master
	# via the web GUI: upstream web > branch: master/develop > "Commpare & PR", ...
	# Thus, I need to update the local master branch accordingly
	git checkout master
	git pull upstream master

	# Finally, it's good practice to delete the feature branch
	# if not done via GitHub web
	git branch -d feature-test
	git push origin --delete feature-test

	```

## Gitlab CI/CD

	-> see ~/git_repositories/cicd_guide/gitlab_ci_cd_howto.md

## DVC

	DVC = Data version control
	For datasets, models and other artifacts.
	DVC also can define reproducible pipelines and track experiments! But that's not shown here.

	DVC artifact tracking works by generating a .dvc file
	for each artifact; then, that file is commited to the git repo
	but the original dataset/artifact is ignored (i.e., in .gitignore)
	and usually stored on a cloud service, e.g., S3, GDrive, etc.

	More information of DVC:
	https://github.com/mxagar/mlops_udacity/blob/main/03_Deployment/MLOpsND_Deployment.md

	Important Links:

	- Documentation: [https://dvc.org/doc/start](https://dvc.org/doc/start).
	- Installation: [https://dvc.org/doc/install](https://dvc.org/doc/install).
	- [DVC Reference](https://dvc.org/doc/command-reference)
	- [Data and Model Access](https://dvc.org/doc/start/data-management/data-and-model-access)
	- [Supported Storage Types](https://dvc.org/doc/command-reference/remote/add#supported-storage-types)

	### Installation

		```bash
		conda activate mlops-nd # Python 3.8

		# with brew (outdated)
		brew install dvc

		# or with pip
		# BUT: we need to have an environment with python 3.8+
		# to have the latest version of dvc
		pip install -U "dvc[all]" # all: all remote storage interfaces are installed

		# also a conda installation is possible,
		# but it didn't work for me
		```

	### Resemblance to Git

		DVC os designed to have a very similar use as git:

		```bash
		# Initialize project, ./dvc/ folder is created
		dvc init

		# Add files/folders to tracking
		dvc add

		# Upload download data from the remote store, specified in dvc.yaml
		dvc push
		dvc pull

		# This one is different than git commit
		dvc commit
		```

	### Tracking with DVC: Local Remote

		```bash
		# 0. Make sure we're on a git repo;
		# if not, initialize first git, then dvc
		git init
		dvc init
		# dvc init generates:
		# .dvc/ folder
		# .dvcignore: equivalent to .gitignore

		# 1. Create a local remote folder
		mkdir ~/data/remote
		dvc remote add -d localremote ~/data/remote
		# list available remotes
		dvc remote list
		# In addition to local remote folders, we can use
		# real remote storage: S3, GDrive, etc.
		# Check how config file changed
		less .dvc/config

		# 2. Track files
		dvc add sample.csv
		# We get a prompt saying that
		# we should add .gitignore
		# and sample.csv.dvc to git
		# NOTE: sample.csv is added to .gitignore for us!
		git add sample.csv.dvc .gitignore

		# 2. Commit changes to git
		git commit -m "initial commit of dataset using dvc"
		# If our git repo is connected to a remote origin
		# we can always do git push/pull

		# 3. Send data to local remote
		dvc push

		# 4. Retrieve data from local remote
		dvc pull

		# 5. Change a dataset and track changes
		vim sample.csv # now, change something
		dvc add sample.csv
		git add sample.csv.dvc
		git commit -m "changes..."
		dvc push

		# 6. Manage remotes
		# Change/add properties to a remote
		dvc remote modify
		# Rename a remote
		dvc remote rename
		# Change a defalut remote
		dvc remote default # we get the name of the current default remote
		dvc remote default <name> # new default remote
		```

		The `sample.csv.dvc` has content of the following form:

		```
		outs:
		- md5: 82c893581e57f7e84418cc44e9c0a3d0
		size: 3856
		path: sample.csv
		```

	### Remote Storage: GDrive, S3

		The true potential of DVC is unlocked when we use remote storage;
		then, we can simply `git clone` any repository anywhere and push/pull remote datasets/models from GDrive, S3, or similar.
		Therefore, we can develop on one machine a deploy on another one without any issues, because the datasets and models are remotely stored.

		Example:

		```bash
		dvc remote add s3remote s3://a/remote/bucket
		```

		Note: We can have multiple remote stores!

		#### Example: GDrive Remote Storage

		```python
		# To work with remote GDrive folders, we need the unique identifier,
		# ie., the last long token in the URL after the last slash '/'
		# Unique identifier: <UNIQUEID>
		# Additionally, dvc-gdrive must be installed (see above)
		dvc remote add driveremote gdrive://<UNIQUEID>
		dvc remote modify driveremote gdrive_acknowledge_abuse true
		# Check how config file changes
		less .dvc/config

		# Push to the gdrive remote
		# Since the local remote is the default,
		# we need to specify the new drive remote
		dvc push --remote driveremote
		# We open the prompted URL and log in to Google
		# or are redirected to a log in window.
		# If a verification code is given on the web
		# we paste it back on the terminal
		# Now, in GDrive, we should see version files

		# If we do dvc push,
		# it pushes to the default remote,
		# which is usually the local remote! 
		dvc push

		# We can change the default remote
		# to be a cloud storage
		dvc remote list # we get the list of all remotes: localremote, driveremote
		dvc remote default # we get the name of the current default remote
		dvc remote default driveremote # new default remote
		```

## Git summary for working in teams

	# -- 1. Create a new branch to work on, forking from the default branch (e.g., dev)

	# Get everything from remote
	git fetch # inspect remote changes before integrating them
	git pull # integrate remote changes

	# Check local branches
	git branch

	# Check local and remote branches
	git branch -a

	# Switch to branch we'd like to derive from, e.g., dev
	git checkout dev
	git pull

	# Create new branch and switch to it
	git checkout -b feature/jira-XXX-concept

	# -- 2. Work on your branch

	# Modify/edit files
	# Then either add all to stage or selected ones
	git add .

	# Commit changes to local repo
	git commit -m "feat: explain changes you made"

	# Push changes to remote repo in branch we are in
	# If first time, we publish branch the first time
	# git push [remote] [branch_name]; remote = origin, branch_name = name of the remote branch,
	# by default same as local
	# If it's the first push, we can publish the branch with
	# git push -u origin [branch_name]
	# the -u flag when pushing for the first time,
	# which sets up tracking between the local and remote branches
	git push origin

	# -- 3. Merge your branch to the branch you forked it from (e.g., dev)

	# Now, we would like to merge our feature/jira-XXX-concept branch
	# to the dev branch.
	# To that end:
	# - FIRST, in case we suspect that somebody changed in dev something that might cause conflicts, we merge dev to feature/jira-XXX-concept; that way we fix any merge issues beforehand. This strategy is well known: "upstream first: keeping your feature branch up to date with the main branch."
	# - SECOND, we merge feature/jira-XXX-concept to dev

	# FIRST step: Merge locally dev to our feature/jira-XXX-concept (where we are)
	# The '--no-ff' flag ensures that even if a fast-forward merge is possible,
	# a new merge commit is created to clearly show that a merge operation took place,
	# making it easier to track when and where branches were merged.
	# If in a file the same function/section was changed simultaneously,
	# we have a conflict and the merge won't be done:
	# git will mark the file as having a conflict and leave it to you to resolve.
	# In that case, 
	# - We need to manually edit the conflicted file
	# to decide which changes to keep and which to discard.
	# - After resolving the conflict,
	# we can then commit the changes to complete the merge.
	# - Once the conflict is resolved and committed,
	# Git will create a new merge commit to record the resolution,
	# and both sets of changes will be incorporated into the 'dev' branch.
	git checkout dev
	git pull
	git checkout feature/jira-XXX-concept
	git pull origin dev
	git merge --no-ff dev
	git checkout feature/jira-XXX-concept
	git push origin
	# NOTE: one way to perform a "dry-run" merge is with the flag "--no-commit"
	# That way, the merge is not performed/committed, but instead it's checked for conflicts:
	# git merge --no-commit --no-ff dev
	# Then, if no conflicts/after resolving them, we finish the merge:
	# git merge --continue

	# SECOND step: Merge locally our feature/jira-XXX-concept (where we are) to dev
	# The end result will be a 'dev' branch that incorporates our changes from feature/jira-XXX-concept
	git checkout dev
	git merge --no-ff feature/jira-XXX-concept
	# BUT, if the feature/jira-XXX-concept branch is pushed to the remote
	# we can do the merge via the web interface of Github/Gitlab
	# We perform a Pull/Merge request via the web.
		
	# GITHUB: Pull request (PR)
	# Open a Pull Request on upstream remote:
	# (base) upstream:dev <- (head, compare) origin:feature/jira-XXX-concept
	# Steps:
	# - Go to GitHub, OUR remote repo (origin)
	# - Navigate to "feature/jira-XXX-concept" branch
	# - "Compare & pull request"
	# - "Create Pull Request"
	# Then, the OTHERS would accept the PR
	# Typically, they:
	# - Review
	# - Wait for checks in the web GUI, then "Merge" and "Confirm"
	# However, we can get change requests back.

	# GITLAB: Merge request (MR)
	# Instructions vary slightly between platforms, but it's a similar process.
	# - Go to GitLab and navigate to your project.
	# - Click on "Merge Requests" in the left sidebar.
	# - Click the "New merge request" button.
	# - Set the source branch (e.g., feature/jira-XXX-concept) and the target branch (e.g., dev).
	# - Review and provide a title and description for your MR.
	# - Assign reviewers if needed.
	# - Click the "Submit merge request" button.
	# - Configure approval options
	# - Others will review your changes, discuss them, and finally "Accept" the MR.
	# - Once accepted, GitLab will automatically merge your changes into the target branch.

	# -- 4. Tidy up

	# Finally, it's good practice to delete the feature branch
	# if not done via GitHub/Gitlab web
	# Locally
	git checkout dev
	git pull origin
	git branch -D feature/jira-XXX-concept
	# and remotely, if not done automatically by Github/Gitlab
	git push origin --delete feature/jira-XXX-concept